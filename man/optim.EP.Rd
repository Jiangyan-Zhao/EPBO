% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EPBO.R
\name{optim.EP}
\alias{optim.EP}
\title{Exact Penalty Bayesian Optimization}
\usage{
optim.EP(
  blackbox,
  B,
  equal = FALSE,
  ethresh = 0.01,
  Xstart = NULL,
  start = 10,
  end = 100,
  urate = 10,
  rho = NULL,
  ncandf = function(k) {
     k
 },
  ey_tol = 0.01,
  dg_start = c(0.1, 1e-06),
  ab = c(3/2, 8),
  dlim = sqrt(nrow(B)) * c(0.001, 10),
  TR_control = list(length = 0.8, length0 = 0.8, length_min = 0.5^7, length_max = 1.6,
    failure_counter = 0, failure_tolerance = nrow(B), success_counter = 0,
    success_tolerance = nrow(B)),
  verb = 2,
  ...
)
}
\arguments{
\item{blackbox}{blackbox of an input (\code{x}), facilitating vectorization on a
\code{matrix} \code{X} thereof,  returning a \code{list}
with elements \code{$obj} containing the (scalar) objective value and \code{$c}
containing a vector of evaluations of the (multiple) constraint function at \code{x}.}

\item{B}{2-column \code{matrix} describing the bounding box.  The number of rows
of the \code{matrix} determines the input dimension (\code{length(x)} in \code{blackbox(x)});
the first column gives lower bounds and the second gives upper bounds}

\item{equal}{an optional vector containing zeros and ones, whose length equals the number of
constraints, specifying which should be treated as equality constraints (\code{1}) and
which as inequality (\code{0})}

\item{ethresh}{a threshold used for equality constraints to determine validity for
progress measures; ignored if there are no equality constraints}

\item{Xstart}{optional matrix of starting design locations in lieu of, or in addition to,
\code{start} random ones;  we recommend \code{nrow(Xstart) + start >= 6}; also must
have \code{ncol(Xstart) = nrow(B)}}

\item{start}{positive integer giving the number of random starting locations before
sequential design (for optimization) is performed; \code{start >= 6} is
recommended unless \code{Xstart} is non-\code{NULL}; in the current version
the starting locations come from a space-filling design via \code{\link[tgp]{dopt.gp}}}

\item{end}{positive integer giving the total number of evaluations/trials in the
optimization; must have \code{end > start}}

\item{urate}{positive integer indicating  how many optimization trials should pass before
each MLE/MAP update is performed for GP correlation lengthscale
parameter(s)}

\item{rho}{positive vector initial exact penalty parameter in the exact penalty function;
the default setting of \code{rho = NULL} causes an automatic starting value to be chosen}

\item{ncandf}{function taking a single integer indicating the optimization trial number \code{t}, where
\code{start < t <= end}, and returning the number of search candidates (e.g., for
expected improvement calculations) at round \code{t}; the default setting
allows the number of candidates to grow linearly with \code{t}}

\item{dg_start}{2-vector giving starting values for the lengthscale and nugget parameters
of the GP surrogate model(s) for constraints}

\item{ab}{prior parameters; see \code{\link{darg}} describing the prior used on the
lengthscale parameter during emulation(s) for the constraints}

\item{dlim}{2-vector giving bounds for the lengthscale parameter(s) under MLE/MAP inference,
thereby augmenting the prior specification in \code{ab}}

\item{TR_control}{an optional list of control parameters of the trust region. See "Details".}

\item{verb}{a non-negative integer indicating the verbosity level; the larger the value the
more that is printed to the screen}

\item{...}{additional arguments passed to \code{blackbox}}
}
\value{
The output is a \code{list} summarizing the progress of the evaluations of the
blackbox under optimization:
\item{prog }{ vector giving the best feasible (\code{g(x) <= 0 && |h(x)| <= ethresh}) value of the objective over the trials }
\item{xbest }{ vector giving the recommended solution}
\item{obj }{ vector giving the value of the objective for the input under consideration at each trial }
\item{C }{ \code{matrix} giving the value of the constraint function for the input under consideration at each trial}
\item{X }{ \code{matrix} giving the input values at which the blackbox function was evaluated }
\item{idx_v}{index of the valid solutions}
}
\description{
Black-box optimization under mixed equality and inequality constraints via an exact penalty.
}
\details{
Additional details...
}
\examples{
## Inequality constrained problem
# search space
B = rbind(c(0, 1), c(0, 1)) 
# Objective and constraint function for use 
HSQ = function(x){
  B = rbind(c(0, 1), c(0, 1))
  x = pmin(pmax(B[,1], x), B[,2])
  t = function(z)
    return(exp(-(z-1)^2) + exp(-0.8*(z+1)^2) - 0.05*sin(8*(z+0.1)))
  herbtooth = -t(4*x[1]-2)*t(4*x[2]-2)
  c1 = 1.5 - x[1] - 2*x[2] - 0.5*sin(2*pi*(x[1]^2 - 2*x[2]))
  c2 = x[1]^2 + x[2]^2 - 1.5
  return(list(obj=herbtooth, c=cbind(c1,c2)))
}
EPBO = optim.EP(HSQ, B, ncandf = function(k){ 1e3 }, start = 20, end = 120, verb = 0)
# progress, best feasible value of the objective over the trials
EPBO$prog
# the recommended solution
EPBO$xbest

## Mixed constrained problem
# search space
B = rbind(c(0, 1), c(0, 1))
# Objective and constraint function for use 
goldstein.price = function(X) 
{
  if(is.null(nrow(X))) X <- matrix(X, nrow=1)
  m <- 8.6928
  s <- 2.4269
  x1 <- 4 * X[,1] - 2
  x2 <- 4 * X[,2] - 2
  a <- 1 + (x1 + x2 + 1)^2 * (19 - 14 * x1 + 3 * x1^2 - 14 * x2 + 6 * x1 * x2 + 3 * x2^2)
  b <- 30 + (2 * x1 - 3 * x2)^2 * (18 - 32 * x1 + 12 * x1^2 + 48 * x2 - 36 * x1 * x2 + 27 * x2^2)
  f <- log(a * b)
  f <- (f - m)/s
  return(f)
}

toy.c1 <- function(X) {
  if (is.null(dim(X))) X <- matrix(X, nrow=1)
  c1 = 3/2 - X[,1] - 2*X[,2] - .5*sin(2*pi*(X[,1]^2 - 2*X[,2]))
}

branin.c = function(X){
  if (is.null(dim(X))) X <- matrix(X, nrow=1)
  x1 = X[,1] * 15 - 5
  x2 = X[,2] * 15
  f = (x2 - 5/(4 * pi^2) * (x1^2) + 5/pi * x1 - 6)^2 + 10 * (1 - 1/(8 * pi)) * cos(x1) + 10
  return(-f+25)
}

parr <- function(X){
  if (is.null(dim(X))) X <- matrix(X, nrow=1)
  x1 <- (2 * X[,1] - 1)
  x2 <- (2 * X[,2] - 1)
  g <- (4-2.1*x1^2+1/3*x1^4)*x1^2 + x1*x2 + (-4+4*x2^2)*x2^2 + 
    3*sin(6*(1-x1)) + 3*sin(6*(1-x2))
  return(-g+4)
}

gsbp.constraints <- function(x){
  return(cbind(toy.c1(x), branin.c(x), parr(x)))
}

# problem definition
gsbpprob <- function(X, known.only=FALSE)
{ 
  if(is.null(nrow(X))) X <- matrix(X, nrow=1)
  if(known.only) stop("known.only not supported for this example")
  f = goldstein.price(X)
  C = gsbp.constraints(X)
  return(list(obj=f, c=cbind(C[,1], C[,2]/100, C[,3]/10)))
}
EPBO = optim.EP(gsbpprob, B, ncandf = function(k){ 1e3 }, start = 20, end = 120, 
                ethresh = 1e-2, equal = c(0,1,1), verb = 0)
                
# progress, best feasible value of the objective over the trials
EPBO$prog
# the recommended solution
EPBO$xbest
}
\seealso{
\code{\link[laGP]{optim.auglag}}, \code{\link[laGP]{optim.efi}}, \code{\link[EPBO]{optim.AE}}, \code{\link[EPBO]{optim.BM}}
}
\author{
Jiangyan Zhao \email{zhaojy2017@126.com}
}
\keyword{design}
\keyword{optimize}
